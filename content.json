{"meta":{"title":"NotFoundHY","subtitle":"","description":"","author":"黄阳","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2019-11-30T10:07:35.000Z","updated":"2019-11-30T10:32:45.851Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-30T10:25:35.000Z","updated":"2019-11-30T10:31:44.742Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构-栈","slug":"数据结构-栈","date":"2019-08-18T16:00:00.000Z","updated":"2019-08-19T08:59:20.577Z","comments":true,"path":"2019/08/19/数据结构-栈/","link":"","permalink":"http://yoursite.com/2019/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/","excerpt":"","text":"数据结构-栈​ 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 ​ 栈符合先进后出（First In Last Out，FILO） ​ 例如一堆叠了盘子，只能从盘子的顶部取出盘子 栈的示意图 Java代码实现测试代码：1package datastrcts;2&#x2F;*3* 模拟数据结构-栈的实现4* *&#x2F;5public class StackDemo &#123;6 public static void main(String[] args) &#123;7 &#x2F;&#x2F;测试数组实现的栈8 &#x2F;* ArrayStack arrayStack &#x3D; new ArrayStack(4);9 System.out.println(&quot;入栈&quot;);10 arrayStack.push(1);11 arrayStack.push(2);12 arrayStack.push(3);13 arrayStack.push(4);14 arrayStack.show();15 System.out.println(&quot;出栈&quot;);16 arrayStack.pop();17 arrayStack.pop();18 arrayStack.pop();19 arrayStack.show();20 System.out.println(&quot;出栈到栈底&quot;);21 arrayStack.pop();22 arrayStack.show();*&#x2F;23 &#x2F;&#x2F;测试链表实现的栈24 LinkedStack linkedStack &#x3D; new LinkedStack();25 linkedStack.init();26 linkedStack.push(1);27 linkedStack.push(2);28 linkedStack.push(3);29 System.out.println(&quot;栈中所有元素：&quot;);30 linkedStack.show();31 Object object &#x3D; linkedStack.pop();32 System.out.println(&quot;出栈的元素为&quot;+object);33 System.out.println(&quot;出栈后栈中的元素：&quot;);34 linkedStack.show();35 linkedStack.pop();36 linkedStack.pop();37 linkedStack.pop();38 &#125;39&#125; 数组模拟栈：1&#x2F;*2* 用数组模拟栈*&#x2F;3class ArrayStack&#123;4 int top &#x3D; -1;5 int Maxsize;6 int stack [];7 &#x2F;&#x2F;构造方法8 public ArrayStack(int maxsize) &#123;9 Maxsize &#x3D; maxsize;10 stack &#x3D; new int[Maxsize];11 &#125;12 &#x2F;&#x2F;判断栈是否为空13 public boolean isEmpty()&#123;14 return top &#x3D;&#x3D; -1;15 &#125;16 &#x2F;&#x2F;判断栈是否满17 public boolean isFull()&#123;18 return top &#x3D;&#x3D; Maxsize;19 &#125;20 &#x2F;&#x2F;入栈21 public void push(int data)&#123;22 if (isFull())&#123;23 System.out.println(&quot;栈已满无法入栈&quot;);24 return;25 &#125;else &#123;26 top++;27 stack[top] &#x3D; data;28 &#125;29 &#125;30 &#x2F;&#x2F;出栈31 public int pop()&#123;32 if (isEmpty())&#123;33 throw new RuntimeException(&quot;栈为空&quot;);34 &#125;else &#123;35 int value &#x3D; stack[top];36 top--;37 return value;38 &#125;39 &#125;40 public void show ()&#123;41 if (isEmpty())&#123;42 System.out.println(&quot;栈空，没有数据~~&quot;);43 return;44 &#125;else &#123;45 System.out.println(&quot;栈中的元素为：&quot;);46 for (int i &#x3D; top; i &gt;&#x3D; 0;i--)&#123;47 System.out.print(stack[i]+&quot; &quot;);48 &#125;49 System.out.println(&quot; &quot;);50 &#125;51 &#125;52&#125; 数组模拟栈测试结果 单链表模拟栈：1&#x2F;*2 * 用链表模拟栈*&#x2F;3class LinkedStack&#123;4 class Node &#123;&#x2F;&#x2F; 定义节点5 private Node next;6 public Object value;7 &#125;89 Node top &#x3D; null;10 &#x2F;&#x2F;初始化top结点11 void init() &#123;12 top &#x3D; new Node();13 top.next &#x3D; null;14 top.value &#x3D; null;15 &#125;16 &#x2F;&#x2F;判断是否为空栈17 public boolean isEmpty()&#123;18 return top.next &#x3D;&#x3D; null;19 &#125;20 &#x2F;&#x2F;入栈21 public void push(Object object)&#123;22 Node e &#x3D; new Node();23 e.value &#x3D; object;24 if (isEmpty())&#123;25 top.next &#x3D; e;26 &#125;else &#123;27 e.next &#x3D; top.next;28 top.next &#x3D; e;29 &#125;30 &#125;31 &#x2F;&#x2F;出栈32 public Object pop()&#123;33 Object obj;34 if (isEmpty())&#123;35 System.out.println(&quot;栈为空，无法出栈&quot;);36 return 0;37 &#125;else &#123;38 obj &#x3D; top.next.value;39 top.next &#x3D; top.next.next;40 return obj;41 &#125;42 &#125;43 &#x2F;&#x2F;打印栈中存在的元素44 public void show() &#123;45 Node temp &#x3D; top;46 if(temp.next&#x3D;&#x3D;null)47 &#123;48 System.out.println(&quot;栈为空！&quot;);49 &#125;50 while (temp.next !&#x3D; null) &#123;51 System.out.print(temp.next.value + &quot; &quot;);52 temp &#x3D; temp.next;53 &#125;54 System.out.println(&quot;&quot;);55 &#125;56&#125; 单链表模拟栈测试结果","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"MySQL表的操作（2）","slug":"MySQL表的操作（2）","date":"2019-08-16T16:00:00.000Z","updated":"2019-08-18T09:23:50.880Z","comments":true,"path":"2019/08/17/MySQL表的操作（2）/","link":"","permalink":"http://yoursite.com/2019/08/17/MySQL%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89/","excerpt":"","text":"MySQL表的操作（2）一、简单查询语句： 查询指定列名： 1select 列名,列名... from 表名 查询所有列： 1select * from 表名 过滤重复行： 1select distinct 列名 from 表名 改变查询结果的标题： 1select 列名 as 标题名 from 表名 计算列值： 1select 列名+运算符+数值 from 表名 1select grade*100 from students 二、选择查询 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true (A = B) 返回false。 &lt;&gt;, != 不等于，检测两个值是否相等，如果不相等返回true (A != B) 返回 true。 &gt; 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true (A &gt; B) 返回false。 &lt; 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true (A &lt; B) 返回 true。 &gt;= 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true (A &gt;= B) 返回false。 &lt;= 小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true (A &lt;= B) 返回 true 关系表达式： 1select * from 成绩表 where 成绩&gt;&#x3D;60 逻辑表达式： NOT、AND、OR 例： 1select * from 学生表 where 专业&#x3D;&#39;计算机&#39; and 性别&#x3D;&#39;男&#39; 1select * from 学生表 where 专业&#x3D;&#39;计算机&#39; or 性别&#x3D;&#39;男&#39; BETWEEN关键字： 1select * from 成绩表 where 成绩 between 80 and 902或者：3select * from 成绩表 where 成绩&gt;&#x3D;80 and 成绩&lt;&#x3D;90 IN关键字： 表达式[NOT] IN （表达式1,表达式2,表达式3…） 1select * from 学生表 where 专业 in (&#39;计算机&#39;,&#39;网络工程&#39;) LIKE关键字： ​ LIKE关键字 1select * from 学生表 where 姓名 like&#39;张%&#39; IS [NOT] NULL 查询： 1select * from 成绩表 where 成绩 is null2select * from 成绩表 where 成绩 is not null 复合条件查询： 1select * from 学生表 where 性别&#x3D;&#39;&#39;女 and (专业&#x3D;&#39;计算机&#39; or 专业&#x3D;&#39;网络工程&#39;) 聚合函数查询： 函数名 释义 count(*) 统计所有列 count() 统计某一列 max() 统计最大值 min() 统计最小值 avg() 统计平均值 sum() 统计和 1select avg(成绩) as 平均成绩 from 成绩表 1select count（distinct 专业） as 专业个数 三、分组查询group by GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 1SELECT column_name, function(column_name)2FROM table_name3WHERE column_name operator value4GROUP BY column_name; 1 select job,count(job) from emp group by job;2+-----------+------------+3| job | count(job) |4+-----------+------------+5| ANALYST | 2 |6| CLERK | 4 |7| MANAGER | 3 |8| PRESIDENT | 1 |9| SALESMAN | 4 |10+-----------+------------+ 1mysql&gt; select job,count(job) from emp group by job having count(job)&gt;2;2+----------+------------+3| job | count(job) |4+----------+------------+5| CLERK | 4 |6| MANAGER | 3 |7| SALESMAN | 4 |8+----------+------------+ 1mysql&gt; select job,count(job) from emp group by job with rollup;2+-----------+------------+3| job | count(job) |4+-----------+------------+5| ANALYST | 2 |6| CLERK | 4 |7| MANAGER | 3 |8| PRESIDENT | 1 |9| SALESMAN | 4 |10| NULL | 14 |11+-----------+------------+126 rows in set (0.00 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据表","slug":"数据表","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E8%A1%A8/"}]},{"title":"MySQL表的操作（1）","slug":"MySQL表的操作","date":"2019-08-16T16:00:00.000Z","updated":"2019-08-17T12:32:29.853Z","comments":true,"path":"2019/08/17/MySQL表的操作/","link":"","permalink":"http://yoursite.com/2019/08/17/MySQL%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL表的操作（1）一、表的创建和修改等创建表： 1CREATE TABLE 表名 (2 属性名 数据类型 [完整约束条件],3 属性名 数据类型 [完整约束条件],4 ...5 ...6 属性名 数据类型 [完整约束条件]7); 例如创建学生表： 1create table student(id char(7) not null,2 name char(8) not null,3 sex char(2) not null,4 age int,5 sctime date,6 major varchar(20) ,7 primary key(id)8 ）default charset&#x3D;utf8; 完整性约束条件表： 约束条件 说明 PRIMARY KEY 标识该属性为该表的主键，可以唯一的标识对应的元组 FOREIGN KEY 标识该属性为该表的外键，是与之联系某表的主键 NOT NULL 标识该属性不能为空 UNIQUE 标识该属性的值是唯一的 AUTO_INCREMENT 标识该属性的值是自动增加，这是MySQL的SQL语句的特色 DEFAULT 为该属性设置默认值 修改表示例： （1）修改表名： ​ ALTER TABLE 旧表名 RENAME 新表名; 示例： 1alter table student rename students; （2）修改字段的数据类型 ​ ALTER TABLE 表名 MODIFY 属性名 数据类型; 示例： 1alter table student modify name varchar(50); （3）修改字段名： ​ ALTER TABLE 表名 CHANGE 旧属性名 新属性名 新数据类型; 示例： 1alter table students change id stu_id int; 修改过后： 1+--------+-------------+------+-----+---------+-------+2| Field | Type | Null | Key | Default | Extra |3+--------+-------------+------+-----+---------+-------+4| stu_id | int(11) | NO | PRI | 0 | |5| name | varchar(50) | YES | | NULL | |6| sex | char(2) | NO | | NULL | |7| age | int(11) | YES | | NULL | |8| sctime | date | YES | | NULL | |9| major | varchar(20) | YES | | NULL | |10+--------+-------------+------+-----+---------+-------+ （4）增加字段 ​ ALTER TABLE 表名 ADD 属性名1 数据类型 [完整性约束条件] [FIRST | AFTER 属性名2]; 其中，“属性名1”参数指需要增加的字段的名称；“FIRST”参数是可选参数，其作用是将新增字段设置为表的第一个字段；“AFTER”参数也是可选的参数，其作用是将新增字段添加到“属性名2”后面；“属性名2”当然就是指表中已经有的字段 示例： ​ 添加老师字段在课程名之后 1alter table course add teacher varchar(10) after cname; (4)删除字段 ​ ALTER TABLE 表名 DROP 属性名; 示例： 删除students的年龄字段 1alter table students drop age; 1describe students;2+--------+-------------+------+-----+---------+-------+3| Field | Type | Null | Key | Default | Extra |4+--------+-------------+------+-----+---------+-------+5| stu_id | int(11) | NO | PRI | 0 | |6| name | varchar(50) | YES | | NULL | |7| sex | char(2) | NO | | NULL | |8| sctime | date | YES | | NULL | |9| major | varchar(20) | YES | | NULL | |10+--------+-------------+------+-----+---------+-------+ 二、插入数据1.为表的所有字段插入数据格式： 1INSERT INTO table_name ( column_list ) VALUES ( value_list ); ​ table_name: 指定要插入数据的表名。 ​ column_list: 指定要插入数据的列。 ​ value_list: 指定每个列要插入的数据。 【注】 a. 字段列和数据值的数量必须相同。 b. 向表中的所有字段插入值的方法有两种: 一种是指定所有字段名，另一种是完全不指定字段名。示例1： 1insert into students values(1021,&#39;张三&#39;,&#39;男&#39;,NOW(),&#39;计算机科学与技术&#39;); 示例2： 1insert into students(name,sex,sctime,major,stu_id) values(&#39;李四&#39;,&#39;男&#39;,NOW(),&#39;网络工程&#39;,1022); 可以看出，插入数据时，不需要按照表定义的顺序插入，只要保证值的顺序与列字段的顺序相同就可以。 2.为表的指定字段插入数据​ 只插入了性别和id的信息 1insert into students(sex,stu_id) values(&#39;女&#39;,1023); 1+--------+------+-----+------------+------------------+2| stu_id | name | sex | sctime | major |3+--------+------+-----+------------+------------------+4| 1021 | 张三 | 男 | 2019-08-17 | 计算机科学与技术 |5| 1022 | 李四 | 男 | 2019-08-17 | 网络工程 |6| 1023 | NULL | 女 | NULL | NULL |7+--------+------+-----+------------+------------------+ 3.同时插入多条记录​ 用 INSERT 语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号隔开 语法格式： INSERT INTO table_name ( column_list ) VALUES ( value_list1 ) , ( value_list2 ), ... ,( value_listn );示例： 1INSERT INTO course (cid,cname,teacher,ctime,cgrade) 2VALUES (&#39;1121&#39;,&#39;数据结构&#39;,&#39;张老师&#39;,20,4),(&#39;1122&#39;,&#39;java&#39;,&#39;李老师&#39;,20,2); 三、修改数据格式： 1UPDATE table_name SET column_name&#x3D;&#39;待修改的数据&#39; WHERE [限定条件] 例如： 1update course set teacher&#x3D;&#39;mike&#39; where cid&#x3D;1121;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据表","slug":"数据表","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E8%A1%A8/"}]},{"title":"Java多线程入门（1）","slug":"Java多线程入门（1）","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T08:09:49.652Z","comments":true,"path":"2019/08/08/Java多线程入门（1）/","link":"","permalink":"http://yoursite.com/2019/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/","excerpt":"","text":"Java多线程入门（1）一个模拟买火车票的程序: 1package JavaFoundation.Thread;23public class ticketThread &#123;4 public static void main(String[] args) &#123;5 ThreadSale t &#x3D; new ThreadSale();6 Thread t1 &#x3D; new Thread(t,&quot;售票窗口1&quot;);7 Thread t2 &#x3D; new Thread(t,&quot;售票窗口2&quot;);8 Thread t3 &#x3D; new Thread(t,&quot;售票窗口3&quot;);9 t1.start();10 t2.start();11 t3.start();12 &#125;13&#125;14class ThreadSale implements Runnable&#123;15 private int tickets &#x3D; 100;16 @Override17 public void run() &#123;18 while (true)&#123;19 if (tickets&gt;0)&#123;20 try &#123;21 Thread.sleep(100);22 &#125; catch (InterruptedException e) &#123;23 e.printStackTrace();24 &#125;25 System.out.println(Thread.currentThread().getName()+&quot;出售第&quot;+tickets-- +&quot;张票&quot;);26 &#125;27 &#125;28 &#125;29&#125; 可以看出,出现了我们不想出现的情况,即火车票数量已经是0了却还是卖出了两张票 这是因为假设当tickets的值为1时,线程1刚好运行完if (tickets&gt;0)代码,进入卖票的代码块.在这时操作系统将cpu切换成线程2运行,此时tickets的值仍然为1,符合条件,线程2也进入卖票代码块.线程2执行卖票并且tickets–变为0后.线程1开始重新运行又让tickets–变为-1. 一、线程相关概念1.线程异步​ 在功能简单的线程中,每个线程包含了自己运行需要的数据或者方法,就不需要关心其它线程的状态或行为,这样的线程是独立的或异步运行的. 2.原子操作​ 当应用问题的功能增强\\关系复杂时,就存在多个线程对共享数据进行操作的需求.当多个线程共享数据时,若仍以异步方式来访问数据,则有可能出现混乱或者不符合逻辑的情况. ​ 所谓原子操作就是当一个线程对共享数据进行操作时,在没有完成相关操作之前,不允许其它线程打断他,形成具有原子性的”原子操作”.否则会破坏数据的完整性. 为临界代码加上互斥锁: 1synchronized (str) &#123;2 if (tickets &gt; 0) &#123;3 try &#123;4 Thread.sleep(100);5 &#125; catch (InterruptedException e) &#123;6 e.printStackTrace();7 &#125;8 System.out.println(Thread.currentThread().getName() + &quot;出售第&quot; + tickets-- + &quot;张票&quot;);9 &#125; else &#123;10 break;11 &#125;12&#125; 但是可以明显发现代码运行速度变慢了,这是因为程序需要不停的对互斥锁是否存在进行检查,需要更多的开销.所以如果没有数据安全方面的需要,就没必要使用同步控制. 同步：安全性高、效率低 异步：效率高、安全性低 二、synchronized 的功能​ 一个线程运行到synchronized 时,首先判断数据或者方法互斥锁是否存在,如果存在则或者互斥锁,然后运行紧随其后的临界代码或者方法体;如果数据或者方法已经被其它线程拿走,则该线程就进入阻塞等待状态,直到获得互斥锁 ​ 当synchronized 限定的代码段运行完后,就释放互斥锁 三、死锁​ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 例如： 线程1 首先占有对象1，接着试图占有对象2 线程2 首先占有对象2，接着试图占有对象1 线程1 等待线程2释放对象2 与此同时，线程2等待线程1释放对象1 就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。 示例代码： 1package JavaFoundation.Thread;2&#x2F;*3* 3个同步对象obj1, obj2, obj34* 3个线程 t1,t2,t35* 故意设计场景，使这3个线程彼此死锁6*&#x2F;7public class deadLockTest &#123;8 public static String obj1 &#x3D; &quot;obj1&quot;;9 public static String obj2 &#x3D; &quot;obj2&quot;;10 public static String obj3 &#x3D; &quot;obj3&quot;;1112 public static void main(String[] args) &#123;13 Thread t1 &#x3D; new Thread()&#123;14 @Override15 public void run() &#123;16 synchronized (obj1)&#123;17 System.out.println(&quot;t1占有了obj1&quot;);18 try &#123;19 Thread.sleep(100);20 &#125; catch (InterruptedException e) &#123;21 e.printStackTrace();22 &#125;23 System.out.println(&quot;t1 等待占有obj2。。。。。。。。。。。&quot;);24 synchronized (obj2)&#123;25 System.out.println(&quot;t1爱做啥做啥&quot;);26 &#125;27 &#125;28 &#125;29 &#125;;30 Thread t2 &#x3D; new Thread()&#123;31 @Override32 public void run() &#123;33 synchronized (obj2)&#123;34 System.out.println(&quot;t2占有了obj2&quot;);35 try &#123;36 Thread.sleep(100);37 &#125; catch (InterruptedException e) &#123;38 e.printStackTrace();39 &#125;40 System.out.println(&quot;t2 等待占有obj3。。。。。。。。。。。&quot;);41 synchronized (obj3)&#123;42 System.out.println(&quot;t2爱做啥做啥&quot;);43 &#125;44 &#125;45 &#125;46 &#125;;47 Thread t3 &#x3D; new Thread()&#123;48 @Override49 public void run() &#123;50 synchronized (obj3)&#123;51 System.out.println(&quot;t3占有了obj3&quot;);52 try &#123;53 Thread.sleep(100);54 &#125; catch (InterruptedException e) &#123;55 e.printStackTrace();56 &#125;57 System.out.println(&quot;t3 等待占有obj1。。。。。。。。。。。&quot;);58 synchronized (obj1)&#123;59 System.out.println(&quot;t3爱做啥做啥&quot;);60 &#125;61 &#125;62 &#125;63 &#125;;64 t1.start();65 t2.start();66 t3.start();67 &#125;68&#125; 四、线程的协作1.常用方法：1.1sleep()方法​ sleep（）方法是线程类Thread的静态方法，调用该方法使线程暂停执行指定的时间，将CPU让给其他线程，并不释放所持有的对象锁，休眠时间结束后线程回到就绪状态。 1.2wait()方法​ wait（）是Object类的方法，调用wait（）方法，线程释放所持有的对象锁，进入等待池中，只有调用notify（）方法（或者notifyAll（）方法），才能唤醒等待池中的线程进入等锁池，若线程获得对象的锁，则线程重新进入就绪状态。在调用 wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。 1.3yield方法​ 暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。 1.4join()方法​ 在很多情况，主线程创建并启动子线程，如果子线程中需要进行大量的耗时计算，主线程往往早于子线程结束。这时，如果主线程想等待子线程执行结束之后再结束，比如子线程处理一个数据，主线程要取得这个数据，就要用待join() 方法。 2.生产者消费者问题​ 生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能： 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内； 如果共享数据区为空的话，阻塞消费者继续消费数据； 1package JavaFoundation.Thread;23import java.util.ArrayList;4import java.util.List;56&#x2F;*7* 本代码模拟生产者消费者问题8* *&#x2F;9public class ProductorConsumer &#123;1011 public static void main(String[] args) &#123;12 List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();13 Productor p &#x3D; new Productor(list,8);14 Thread thread1 &#x3D; new Thread(p,&quot;生产者1&quot;);15 Thread thread2 &#x3D; new Thread(p,&quot;生产者2&quot;);16 Thread thread3 &#x3D; new Thread(p,&quot;生产者3&quot;);17 Consumer c &#x3D; new Consumer(list);18 Thread thread4 &#x3D; new Thread(c,&quot;消费者1&quot;);19 Thread thread5 &#x3D; new Thread(c,&quot;消费者2&quot;);20 Thread thread6 &#x3D; new Thread(c,&quot;消费者3&quot;);21 thread1.start();22 thread2.start();23 thread3.start();24 thread4.start();25 thread5.start();26 thread6.start();27 &#125;28&#125;29&#x2F;&#x2F;生产者30class Productor implements Runnable&#123;31 int i &#x3D;0;32 List&lt;Integer&gt; list;33 int maxLength;3435 public Productor(List&lt;Integer&gt; list, int maxLength) &#123;36 this.list &#x3D; list;37 this.maxLength &#x3D; maxLength;38 &#125;3940 @Override41 public void run() &#123;42 while (true)&#123;43 synchronized (list)&#123;44 while (list.size() &#x3D;&#x3D; maxLength)&#123;45 System.out.println(&quot;生产者&quot;+Thread.currentThread().getName()+&quot;以及生产到最大数量,进行wait&quot;);46 try &#123;47 list.wait();48 &#125; catch (InterruptedException e) &#123;49 e.printStackTrace();50 &#125;51 &#125;52 list.add(++i);53 System.out.println(&quot;生产者&quot;+Thread.currentThread().getName()+&quot;生产了数据&quot;+i);54 list.notifyAll();55 &#125;56 &#125;57 &#125;58&#125;59&#x2F;&#x2F;消费者60class Consumer implements Runnable&#123;61 List&lt;Integer&gt; list;6263 public Consumer(List&lt;Integer&gt; list) &#123;64 this.list &#x3D; list;65 &#125;6667 @Override68 public void run() &#123;69 while (true)&#123;70 synchronized (list)&#123;71 while (list.isEmpty())&#123;72 System.out.println(&quot;消费者&quot;+Thread.currentThread().getName()+&quot;以及消费到最大数量,进行wait&quot;);73 try &#123;74 list.wait();75 &#125; catch (InterruptedException e) &#123;76 e.printStackTrace();77 &#125;78 &#125;79 int e &#x3D; list.remove(0);80 System.out.println(&quot;消费者&quot;+Thread.currentThread().getName()+&quot;消费了数据&quot;+e);81 list.notifyAll();82 &#125;83 &#125;84 &#125;85&#125; 3.线程池简单入门ThreadPoolExecutor构造方法：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) int corePoolSize：核心线程数，即使空闲也仍保留在池中的线程数 int maximumPoolSize：最大线程数 BlockingQueue workQueue：阻塞队列，在执行任务之前用于保存任务的队列 long keepAliveTime：保持激活时间，当线程数大于核心数时，这是多余的空闲线程在终止之前等待新任务的最大时间 1ThreadPoolExecutor threadPool&#x3D; new ThreadPoolExecutor(3, 6, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());2threadPool.execute(p);3threadPool.execute(c); 1Productor p &#x3D; new Productor(list,8);2&#x2F;* Thread thread1 &#x3D; new Thread(p,&quot;生产者1&quot;);3 Thread thread2 &#x3D; new Thread(p,&quot;生产者2&quot;);4 Thread thread3 &#x3D; new Thread(p,&quot;生产者3&quot;);*&#x2F;5 Consumer c &#x3D; new Consumer(list);6 &#x2F;*Thread thread4 &#x3D; new Thread(c,&quot;消费者1&quot;);7 Thread thread5 &#x3D; new Thread(c,&quot;消费者2&quot;);8 Thread thread6 &#x3D; new Thread(c,&quot;消费者3&quot;);9 thread1.start();10 thread2.start();11 thread3.start();12 thread4.start();13 thread5.start();14 thread6.start();*&#x2F;","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java多线程","slug":"java多线程","permalink":"http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"数据结构与算法绪论","slug":"数据结构与算法绪论","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-04T08:00:09.314Z","comments":true,"path":"2019/08/04/数据结构与算法绪论/","link":"","permalink":"http://yoursite.com/2019/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"数据结构与算法绪论如何表示和存储一组电话号码的所有信息———-数据结构设计 如何实现对电话信息的快速查找———————-算法设计 一、数据结构的逻辑结构和物理结构1.逻辑结构：（1）集合结构 : 集合结构中的元素关系，除了同属于一个集合这个关系以外，再无其他关系。 （2）线性结构：线性结构中，元素间的关系就是一对一，顾名思义，一条线性的结构。 （3）树形结构：树形结构中，元素间的关系就是一对多，一颗大叔，伸展出的枝叶，也是类金字塔形。 （4）图形结构：图形结构中，元素间的关系就是多对多，举例：一个人可以通过6个人间接认识到世界上的每一个人。类蛛网形。 2.物理结构：（1）顺序存储结构：是把数据元素存放在地址连续存储单元里，其数据间的逻辑关系和物理关系是一致的(通常借助数组实现) （2）链式存储结构：既然有这种结构就是跟顺序存储结构有了对比，那就是其中逻辑关系和物理关系没有多大的关系因为其中的数据元素会产生变化。也比顺序存储结构更加灵活(通常借助指针实现) 二、数据结构相关术语 数据(Data) 是对客观事物的符号表示，能被计算机识别 数据元素(Data Element) 是数据的基本单位，是数据中的一个“个体” ，通常在计算机程序中作为一个整体进行考虑和处理。一个数据元素可以由多个数据项组成 数据项(Data Item) 是数据结构讨论的最小单位。例如：一本书的书目信息是一个数据元素，那么书目信息中的每一项（例如书名、作者等）则是数据项 数据对象(Data Object) 是具有相同性质的数据元素的集合，是数据的一个子集 数据结构(Data Structure)： 带结构的数据元素的集合 用集合的形式描述，数据结构是一个二元数组：$$Data Structure = (D , R)$$其中：D是数据元素的有限集，R是D上关系的有限集 简而言之，数据元素和其相互关系称为数据结构 他们的关系如下图所示： 三、算法介绍1.算法的概念​ 是对特定问题的求解步骤的一种描述 2.算法具有的5个特性 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷时间内完成 确定性：算法中的每一条指令都必须由明确的含义，无歧义 可行性：一个算法是能行的，即算法中的描述的操作都是可以通过已经实现的基本运算执行有限次来实现的 输入：有零个或多个外部量作为算法的输入 输出：算法至少有一个输出 3.复杂度分析（1）好的算法应该具有的特性 正确性 可读性 健壮性 高效性 (2)时间复杂度时间频度：一个算法中的语句执行次数（计算步）称为语句频度或时间频度，记为T(n) 时间复杂度：$$T(n) = O(f(n))$$f(n)表示执行与算法优劣和问题规模有关的执行次数 O()表示一种运算符号，例如+-*/。作用是去除其他低阶项，包括与最高项相乘的常数，只保留最高项，例如$$f(n) = 2n^2+1,O(f(n))=O(n^2)$$例如一个遍历数组的代码: 1for (int i &#x3D; 0; i &lt; n; i++) &#123;2 方法3&#125; for循环一共执行n次,所以$$T(n) = O(n)$$常见时间复杂度","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"包装类","slug":"包装类","date":"2019-08-01T16:00:00.000Z","updated":"2019-08-02T06:37:22.616Z","comments":true,"path":"2019/08/02/包装类/","link":"","permalink":"http://yoursite.com/2019/08/02/%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"包装类​ Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据。 基本类型对应的包装类 Integer为例构造方法：1Integer(int value) 2构造一个新分配的 Integer对象，该对象表示指定的 int值。 3Integer(String s) 4构造一个新分配 Integer对象，表示 int由指示值 String参数。 String和int的互转（1）字符串转为int： 方法1： 1int intValue() 测试代码： 1String s &#x3D;&quot;10&quot;;2Integer integer &#x3D; new Integer(s);3System.out.println(integer);4int a &#x3D; integer.intValue();5System.out.println(a + 30); 方法2： 1static int parseInt(String s) 测试代码： 1String s &#x3D;&quot;10&quot;;2int a &#x3D; Integer.parseInt(s);3System.out.println(a + 10); 一般使用第二种，因为不用创建Integer的对象 （2）int转为String 方法1：直接在后面加上”” 1int a &#x3D; 10;2String s &#x3D; a+&quot;&quot;;3System.out.println(s); 方法2：String toString() 1int a &#x3D; 10;2String s &#x3D; Integer.toString(a);3System.out.println(s); 方法1更简单 自动装箱和拆箱自动装箱：基本数据类型，直接变成对象 自动拆箱：对象中的数据变回基本数据类型 12&#x2F;&#x2F;手动装箱3Integer a &#x3D; new Integer(4);4&#x2F;&#x2F;自动装箱5Integer a &#x3D; 4;6&#x2F;&#x2F;自动拆箱,相当于int a &#x3D; i.intValue();7Integer i &#x3D;10;8int a &#x3D; i;","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"常用API","slug":"常用API","date":"2019-08-01T16:00:00.000Z","updated":"2019-08-02T05:53:23.358Z","comments":true,"path":"2019/08/02/常用API/","link":"","permalink":"http://yoursite.com/2019/08/02/%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"常用API一、Object类​ 一个类如果不继承一个类，实际上会默认继承object类，如果该类继承了一个类，由于多层继承，始终会有一个类继承了Object类 常用方法toString()方法：返回对象的字符串表示（一般会重写toString方法，否则返回的是一串对于我们没多大意义的16进制 字符串） equals()方法：使用==来比较两个对象是否相等，即比较地址值是否相等 二、System类​ 它包含一些常用的类字段和方法，不能被实例化 常用方法1.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 将指定源数组中的数组从指定位置复制到目标数组的指定位置。 复制数组： 参数1：Object src 源数组 参数2：int srcPos 原数组的起始索引位置 参数3：Object dest 目标数组 参数4：int destPos 目标数组的起始索引位置 参数5：int length 指定接收的元素个数 测试例子： 1int[] a &#x3D; &#123;1,2,3,4,5&#125;;2int[] b &#x3D; new int [5];3System.arraycopy(a,1,b,1,4);4for (int i &#x3D; 0; i &lt; b.length; i++) &#123;5 System.out.print(b[i]);6&#125; 2.currentTimeMillis() 返回当前时间（以毫秒为单位）。 测试例子： 1System.out.println(System.currentTimeMillis());2long start &#x3D; System.currentTimeMillis();3for (int i &#x3D;0;i&lt; 10000;i++)&#123;4 System.out.println(i);5&#125;6long end &#x3D; System.currentTimeMillis();7System.out.println(end - start); 三、Date类​ 表示特定的瞬间，精确到毫秒，可以通过方法来设定自己所表示的时间，可以表示任意时间 构造方法​ Date():创建的是一个表示当前系统时间的Date对象 ​ Date(long date):分配一个 Date对象，并将其初始化为表示自称为“时代”的标准基准时间以后的指定毫秒数，即1970年1月1日00:00:00 GMT ​ 其它方法已过时不推荐使用 1Date date &#x3D; new Date();2&#x2F;&#x2F;System.out.println(date.toLocaleString());3System.out.println(date); 常用方法setTime getTime 1ate.setTime(1000 * 60 *60 * 24);&#x2F;&#x2F;一天的时间2System.out.println(date.toLocaleString());3System.out.println(date.getTime()); SimpleDateFormat类​ 它是DateFormat 的子类，SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 它允许格式化（日期文本），解析（文本日期）和归一化。 构造方法SimpleDateFormat() 构造一个 SimpleDateFormat使用默认模式和日期格式符号为默认的 FORMAT区域设置。SimpleDateFormat(String pattern) 使用给定模式 SimpleDateFormat并使用默认的 FORMAT语言环境的默认日期格式符号。 ​ 例如:SimpleDateFormat simpleDateFormat = new SimpleDateFormat(“yyyy年MM月dd日HH时mm分ss秒”); 常用方法parse(String source) ​ 从给定字符串的开始解析文本以生成日期。 format(Date date) 将日期格式化成日期/时间字符串。 测试代码： ​ 无参构造： 1Date date &#x3D; new Date();2&#x2F;&#x2F;使用无参构造创建simpleDateFormat对象3SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat();4&#x2F;&#x2F;格式化：将日期对象转换成字符串5String s &#x3D; simpleDateFormat.format(date);6System.out.println(s);7&#x2F;&#x2F;解析：将字符串转换成日期对象8Date date1 &#x3D; simpleDateFormat.parse(s);9System.out.println(date1); ​ 有参构造： 1Date date &#x3D; new Date();2&#x2F;&#x2F;使用有参构造3SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;);4&#x2F;&#x2F;格式化：将日期对象转换成字符串5String s &#x3D; simpleDateFormat.format(date);6System.out.println(s);7&#x2F;&#x2F;解析：将字符串转换成日期对象8Date date1 &#x3D; simpleDateFormat.parse(s);9System.out.println(date1);","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"抽象类和接口","slug":"抽象类和接口","date":"2019-07-31T16:00:00.000Z","updated":"2019-08-02T05:50:26.566Z","comments":true,"path":"2019/08/01/抽象类和接口/","link":"","permalink":"http://yoursite.com/2019/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"抽象类和接口一、抽象类抽象类的概念​ 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 ​ 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 ​ 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 ​ 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 示例代码： 1package JavaFoundation;23public class abstractDemo &#123;4&#125;5&#x2F;*6* Animal类是一个抽象类7* 抽象类里的方法只做声明不做具体实现，抽象类里的方法也必须得是抽象的8* 抽象类的特点：9* 1.用关键字abstract修饰10* 2.抽象类不能创建对象（不能实例化）11*12* 抽象类成员的特点：13* 1.可以有成员变量和常量14* 2.可以有构造方法（需要对抽象类的成员变量进行初始化）15* 3.可以有抽象方法和非抽象方法16* *&#x2F;17abstract class Animal&#123;18 public abstract void eat();&#x2F;&#x2F;没有方法体的方法就是抽象方法19&#125;20&#x2F;*cat类继承了抽象类Animal类，所以必须要重写抽象类中的所有抽象方法，否则这个类还是必须定义成抽象类21* 非抽象方法可以不重写22* *&#x2F;23class cat extends Animal&#123;2425 @Override26 public void eat() &#123;27 System.out.println(&quot;猫吃鱼&quot;);28 &#125;29&#125;30class dog extends Animal&#123;3132 @Override33 public void eat() &#123;34 System.out.println(&quot;狗吃屎&quot;);35 &#125;36&#125; 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 二、接口​ 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 ​ 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 ​ 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 ​ 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口、抽象类案例：1package JavaFoundation;23&#x2F;*4 * 接口的成员特点：5 * 只能有抽象方法6 * 只能有常量7 * 接口不能创建对象（不能实例化）8 * 接口中的方法只能使用public abstract修饰（建议手动写上默认修饰符）9 * 默认使用public static final来修饰成员变量10 * 类与接口的关系是实现关系，一个类实现一个接口必修实现他的所有方法11 * *&#x2F;12public class interfaceDemo &#123;13 public static void main(String[] args) &#123;14 basketballPlayer b &#x3D; new basketballPlayer();15 b.name &#x3D; &quot;姚明&quot;;16 b.age &#x3D; 29;17 b.study();18 b.studyEng();19 b.eat();20 pingpongPlayer p &#x3D; new pingpongPlayer();21 p.study();22 p.eat();23 &#125;2425&#125;26class person&#123;27 String name;28 int age;29 String sex;30 public void eat()&#123;31 System.out.println(&quot;吃饭&quot;);32 &#125;33 public person()&#123;&#125;34 public person(String name, int age, String sex) &#123;35 this.name &#x3D; name;36 this.age &#x3D; age;37 this.sex &#x3D; sex;38 &#125;39&#125;40abstract class player extends person&#123;41 public abstract void study();42&#125;43abstract class coach extends person&#123;44 public abstract void coaching();45&#125;46interface studyEnglish&#123;47 public abstract void studyEng();48&#125;49class pingpongPlayer extends player&#123;5051 @Override52 public void study() &#123;53 System.out.println(&quot;学习打乒乓球&quot;);54 &#125;55&#125;56class basketballPlayer extends player implements studyEnglish&#123;5758 @Override59 public void study() &#123;60 System.out.println(&quot;学习打篮球&quot;);61 &#125;6263 @Override64 public void studyEng() &#123;65 System.out.println(&quot;学习英语&quot;);66 &#125;67&#125;68class basketballCoach extends coach implements studyEnglish&#123;6970 @Override71 public void coaching() &#123;72 System.out.println(&quot;教篮球&quot;);73 &#125;7475 @Override76 public void studyEng() &#123;77 System.out.println(&quot;学习英语&quot;);78 &#125;79&#125;80class pingpongCoach extends coach&#123;8182 @Override83 public void coaching() &#123;84 System.out.println(&quot;教乒乓球&quot;);85 &#125;86&#125; final关键字：​ final：修饰符，可以修饰类、成员方法和成员变量 ​ final修饰的类：不能被继承 ​ final修饰的方法：不能被重写 ​ final修饰的变量：不能被修改，是一个常量 ​ 常量： ​ 1.字面值常量：1,2，3 ​ 2.自定义常量：被final修饰的变量，一旦初始化则不可改变","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"static关键字","slug":"static关键字","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T03:52:12.236Z","comments":true,"path":"2019/07/30/static关键字/","link":"","permalink":"http://yoursite.com/2019/07/30/static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"static关键字用途​ 在《Java编程思想》P86页有这样一段话： “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” 这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是： 方便在没有创建对象的情况下来进行调用（方法/变量）。 很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 static的特点：​ 被所有对象所共享 ​ 可以使用类名调用 ​ 静态的加载优先于对象，随着类的加载而加载 静态方法： ​ 可以调用静态成员变量 ​ 也可以调用其它静态方法 ​ 不可以调用非静态成员变量 ​ 不可以调用非静态成员方法 非静态方法： ​ 可以调用静态的成员变量和成员方法 ​ 可以调用非静态的成员变量和成员方法 静态方法没有this对象 例子： ​ Math类中所有的成员变量和成员方法都是static修饰的，所以Math可以通过类名来直接调用他的方法，例如：Math.PI; 如果将构造方法私有（用private关键字来修饰）后就无法创建这个类的对象 构造代码块​ 直接在类里面用{}包裹 ​ 只要创建了对象就会执行构造代码块（需要抽取重复的代码时使用） ​ 有几个对象就会执行几次构造代码块】 静态代码块：​ static{ ​ 方法 ​ } ​ 只会执行一次，因为静态代码块和对象无关 作用： ​ 在类加载时就初始化一些操作，例如加载驱动 加载顺序代码： 1package com.itheima_04;23&#x2F;*4 * Coder静态代码块执行 --- Coder构造代码块执行 --- Coder无参空构造执行5 * 6 * 7 * BlockTest静态代码块执行 --- BlockTest的主函数执行了 --- Coder静态代码块执行 --- Coder构造代码块执行 --- Coder无参空构造执行8 * Coder构造代码块执行 --- Coder无参空构造执行9 * 10 *&#x2F;11public class BlockTest &#123;12 static &#123;13 System.out.println(&quot;BlockTest静态代码块执行&quot;);14 &#125;15 16 &#123;17 System.out.println(&quot;BlockTest构造代码块执行&quot;);18 &#125;19 2021 public BlockTest()&#123;22 System.out.println(&quot;BlockTest无参构造执行了&quot;);23 &#125;24 25 public static void main(String[] args) &#123;26 System.out.println(&quot;BlockTest的主函数执行了&quot;);27 Coder c &#x3D; new Coder();28 Coder c2 &#x3D; new Coder();29 &#125;30&#125;3132class Coder &#123;33 34 static &#123;35 System.out.println(&quot;Coder静态代码块执行&quot;);36 &#125;37 38 &#123;39 System.out.println(&quot;Coder构造代码块执行&quot;);40 &#125;41 42 public Coder() &#123;43 System.out.println(&quot;Coder无参空构造执行&quot;);44 &#125; 45 46&#125;","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"继承","slug":"继承","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T03:53:11.868Z","comments":true,"path":"2019/07/30/继承/","link":"","permalink":"http://yoursite.com/2019/07/30/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承继承的概念继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 类的继承格式 1class 父类 &#123; 2 3&#125; 45class 子类 extends 父类 &#123; 6 7&#125; 继承的特点​ JAVA语言只支持单一继承，只能继承一个父类 ​ JAVA语言支持多层继承（例如二哈继承狗类，狗继承动物类） ​ 子类只能获取父类的非私有成员 super关键字：可以获取父类的成员变量和成员方法 例如 1&#x2F;*2 * 继承中成员变量的特点3 * 子类只能获取父类非私有成员4 * 子父类中成员变量的名字不一样直接获取父类的成员变量5 * 子父类中成员变量名字是一样的获取的是子类的成员变量6 * 7 * 就近原则：谁离我近我就用谁8 * 如果有局部变量就使用局部变量9 * 如果没有局部变量，有子类的成员变量就使用子类的成员变量10 * 如果没有局部变量和子类的成员变量，有父类的成员变量就使用父类的成员变量11 * 啥都没有，出错了！！！12 * 13 * super:可以获取父类的成员变量和成员方法,用法和this是相似的14 *&#x2F;15public class ExtendsDemo3 &#123;16 public static void main(String[] args) &#123;17 Kid3 k &#x3D; new Kid3();18 k.show();19 &#125;20&#125;2122class Dad3 &#123;23 String name &#x3D; &quot;建霖&quot;;24&#125;2526class Kid3 extends Dad3 &#123;27 String name &#x3D; &quot;四葱&quot;;28 29 public void show() &#123;30 String name &#x3D; &quot;五葱&quot;;31 32 System.out.println(super.name);&#x2F;&#x2F;输出建霖33 System.out.println(this.name);&#x2F;&#x2F;输出四葱34 System.out.println(name);&#x2F;&#x2F;输出五葱35 &#125;36&#125; 继承中成员方法的重写继承中成员方法的特点： ​ 子类中没有这个方法，调用父类的 ​ 子类中重写了这个方法，调用子类的 方法的重写：在子父类当中，子类的方法和父类的完全一样，子类重写了父类的方法（覆盖），当子类重写了父类的方法之后，使用子类对象调用的就是子类的方法 方法的重载：在一个类中，有多个重名的方法，但是其参数不一样（参数的个数，参数的类型，参数的顺序），和返回值无关注意事项： ​ 最好加上@override ​ 重写时的修饰符以及函数名参数必须和父类的一样 this和super： ​ this：当前对象的引用 ​ 可以调用当前类的成员变量和方法 ​ super：子类对象的父类引用 ​ 调用父类的成员变量和方法 继承的优缺点： 优点： 提高代码的复用性 提高可维护性 缺点： 类的耦合性增强了（开发原则：高内聚低耦合 ）","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"集合","slug":"ArrayList集合","date":"2019-07-28T16:00:00.000Z","updated":"2019-08-03T07:16:06.997Z","comments":true,"path":"2019/07/29/ArrayList集合/","link":"","permalink":"http://yoursite.com/2019/07/29/ArrayList%E9%9B%86%E5%90%88/","excerpt":"","text":"ArrayList集合​ ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了ICollection和IList接口，灵活的设置数组的大小等好处 ​ List 接口的大小可变数组的实现，位于API文档的java.util.ArrayList。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 创建一个存储字符串的ArrayList对象： ​ ArrayList arraylist= new ArrayList(); 添加元素： ​ public boolean add(E e):添加元素 ​ public void add(int index,E element):在指定索引处添加一个元素 获取元素： ​ public E get(int index):返回指定索引处的元素 集合长度： ​ public int size():返回集合中的元素个数 删除元素： ​ public boolean remove(Object o):删除指定的元素，返回是否删除成功 ​ public E remove(int index):删除指定索引处的元素，返回被删除的元素 修改元素： ​ public E set(int index,E element):修改指定索引处的元素，返回被修改的元素 代码： 1package JavaFoundation;23import java.util.ArrayList;45public class ArrayListTest &#123;6 public static void main(String[] args) &#123;7 ArrayList&lt;String&gt; arrayList &#x3D; new ArrayList&lt;&gt;();8 &#x2F;&#x2F;public boolean add(E e):添加元素9 arrayList.add(&quot;hello&quot;);10 arrayList.add(&quot;world&quot;);11 arrayList.add(&quot;test&quot;);12 &#x2F;&#x2F;public void add(int index,E element):在指定索引处添加一个元素13 arrayList.add(1,&quot;android&quot;);14 System.out.println(arrayList);15 &#x2F;&#x2F;获取元素：public E get(int index):返回指定索引处的元素16 System.out.println(arrayList.get(1));17 &#x2F;&#x2F;集合长度：public int size():返回集合中的元素个数18 System.out.println(arrayList.size());19 &#x2F;*20 * 删除元素：21​ public boolean remove(Object o):删除指定的元素，返回是否删除成功22​ public E remove(int index):删除指定索引处的元素，返回被删除的元素23 * *&#x2F;24 System.out.println(arrayList.remove(&quot;test&quot;));25 System.out.println(arrayList.remove(2));26 &#x2F;&#x2F;修改元素：public E set(int index,E element):修改指定索引处的元素，返回被修改的元素27 System.out.println(arrayList.set(0,&quot;apple&quot;));28 System.out.println(arrayList);29 &#x2F;&#x2F;集合的遍历30 for (int i&#x3D;0;i&lt;arrayList.size();i++)&#123;31 System.out.println(arrayList.get(i));32 &#125;33 &#125;34&#125; List集合​ List是一个接口，而ArrayList是List接口的一个实现类。 ArrayList类继承并实现了List接口。 因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。 例如： 1List list &#x3D; new ArraryList(); 特点： 有序的 有整数索引 允许重复 常用方法：void add (int index,E element) E get (int index) E remove(int index) E set(int index , E element) 常用子类：Arraylist：底层是数组结构，查询快，增删慢 LinkedList：底层是链表，查询慢，增删快 如何选择不同的集合：查询多，增删少，使用Arraylist ​ 查询少，增删多，使用LinkedList","categories":[{"name":"java语法基础","slug":"java语法基础","permalink":"http://yoursite.com/categories/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java api","slug":"java-api","permalink":"http://yoursite.com/tags/java-api/"}]},{"title":"单向链表","slug":"单向链表","date":"2019-07-21T16:00:00.000Z","updated":"2019-08-01T03:35:43.727Z","comments":true,"path":"2019/07/22/单向链表/","link":"","permalink":"http://yoursite.com/2019/07/22/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单向链表概念​ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 例如： 小结： 链表是以节点的方式存储，链式存储 每个节点包含data域、next域：指向下一个节点 链表的各个节点不一定是连续存储 链表分带头结点的链表和没有头结点的链表，根据实际需求确定 单链表(带头结点)逻辑结构示意图如下： JAVA代码实现：1package datastrcts;23import java.security.PublicKey;4import java.util.Stack;56import static java.lang.reflect.Array.getLength;78public class SingleLinkedListDemo &#123;9 public static void main(String[] args) &#123;10 List list1 &#x3D; new List(1,&quot;张三&quot;);11 List list2 &#x3D; new List(2,&quot;李四&quot;);12 List list3 &#x3D; new List(3,&quot;王二&quot;);13 List list4 &#x3D; new List(4,&quot;张四&quot;);14 SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();&#x2F;&#x2F;创建一个链表15 &#x2F;* singleLinkedList.add(list1);16 singleLinkedList.add(list3);17 singleLinkedList.add(list2);18 singleLinkedList.add(list4);*&#x2F;19 singleLinkedList.addByorder(list1);20 singleLinkedList.addByorder(list3);21 singleLinkedList.addByorder(list2);22 singleLinkedList.addByorder(list4);23 System.out.println(&quot;所有结点数据为：&quot;);24 singleLinkedList.show();25 &#x2F;&#x2F;singleLinkedList.update(new List(3,&quot;wangsan&quot;));26 &#x2F;&#x2F;删除结点27 &#x2F;&#x2F;System.out.println(&quot;----------------------&quot;);28 &#x2F;&#x2F;singleLinkedList.del(list3);29 &#x2F;&#x2F;singleLinkedList.show();30 System.out.println(&quot;----------------------&quot;);31 System.out.println(&quot;链表中的结点个数为：&quot;+getLenth(singleLinkedList.getHead()));32 System.out.println(&quot;----------------------&quot;);33 System.out.println(&quot;倒数第k个结点为：&quot;+getKlist(singleLinkedList.getHead(),3));34 System.out.println(&quot;----------------------&quot;);35 &#x2F;&#x2F;System.out.println(&quot;反转后的链表为：&quot;);36 &#x2F;&#x2F; reversetList(singleLinkedList.getHead());37 &#x2F;&#x2F;singleLinkedList.show();38 reversePrint(singleLinkedList.getHead());3940 &#125;41 &#x2F;&#x2F;获得链表的长度42 public static int getLenth(List head)&#123;43 int lenth&#x3D;0;44 if (head.next&#x3D;&#x3D;null)&#123;45 return 0;46 &#125;else &#123;47 List temp &#x3D; head.next;48 while (temp!&#x3D;null)&#123;49 lenth++;50 temp&#x3D;temp.next;51 &#125;52 &#125;53 return lenth;54 &#125;55 &#x2F;&#x2F;获得链表的倒数第k个结点56 public static List getKlist(List head,int index)&#123;57 List cur &#x3D; head.next;58 &#x2F;&#x2F;判断如果链表为空，返回null59 if(head.next &#x3D;&#x3D; null) &#123;60 return null;&#x2F;&#x2F;没有找到61 &#125;62 &#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)63 int size &#x3D; getLenth(head);64 &#x2F;&#x2F;第二次遍历 size-index 位置，就是我们倒数的第K个节点65 &#x2F;&#x2F;先做一个index的校验66 if(index &lt;&#x3D;0 || index &gt; size) &#123;67 return null;68 &#125;69 &#x2F;&#x2F;定义给辅助变量， for 循环定位到倒数的index70 for(int i &#x3D;0; i&lt; size - index; i++) &#123;71 cur &#x3D; cur.next;72 &#125;73 return cur;74 &#125;75 &#x2F;&#x2F;链表反转76 public static void reversetList(List head)&#123;77 &#x2F;*如果链表只有一个节点或者为空链表直接退出*&#x2F;78 if (head.next&#x3D;&#x3D;null||head.next.next&#x3D;&#x3D;null)&#123;79 return ;80 &#125;81 List cur &#x3D; head.next;82 List next &#x3D; null;83 List reversethead &#x3D; new List(0,&quot;&quot;);84 &#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端85 while (cur !&#x3D; null)&#123;86 next &#x3D; cur.next;87 cur.next &#x3D; reversethead.next;88 reversethead.next &#x3D; cur;89 cur &#x3D; next;90 &#125;91 head.next&#x3D;reversethead.next;&#x2F;&#x2F;将临时链表的头指针赋给原来链表。92 &#125;93 &#x2F;&#x2F;逆序打印链表94 &#x2F;*利用栈先进后出的特性实现逆序打印链表*&#x2F;95 public static void reversePrint(List head)&#123;96 Stack&lt;List&gt; temp &#x3D; new Stack&lt;List&gt;();97 &#x2F;*如果链表为空链表直接退出*&#x2F;98 if (head.next&#x3D;&#x3D;null)&#123;99 return ;100 &#125;101 List cur &#x3D; head.next;102 while (cur!&#x3D;null)&#123;103 temp.push(cur);&#x2F;&#x2F;将节点传入栈中104 cur &#x3D; cur.next;105 &#125;106 while (temp.size()&gt;0)&#123;107 System.out.println(temp.pop());108 &#125;109 &#125;110 &#x2F;&#x2F;合并两个有序的链表，合并后依然有序111 112&#125;113class SingleLinkedList&#123;114 private List head &#x3D; new List(0,&quot;&quot;);115116 public List getHead() &#123;117 return head;118 &#125;119120 &#x2F;&#x2F;链表的添加方法（直接添加到链表的尾部，不考虑顺序）121 public void add(List list)&#123;122 List temp &#x3D; head;&#x2F;&#x2F;使用临时变量存储头结点123 &#x2F;*124 * 当temp的next为空时说明已经到了链表的尾部125 * *&#x2F;126 while (true)&#123;127 if(temp.next &#x3D;&#x3D; null)&#123;128 break;129 &#125;130 temp&#x3D;temp.next;131 &#125;132 temp.next&#x3D;list;&#x2F;&#x2F;将新的结点加入链表，即将值赋给最后一个结点的next域133 &#125;134 &#x2F;&#x2F;有序添加135 public void addByorder(List list)&#123;136 List temp &#x3D; head;&#x2F;&#x2F;使用临时变量存储头结点137 &#x2F;*138 * 当temp的next为空时说明已经到了链表的尾部139 * *&#x2F;140 boolean flag &#x3D; false;&#x2F;&#x2F;标志位，判断要添加的结点是否存在141 while (true)&#123;142 if(temp.next &#x3D;&#x3D; null)&#123;143 break;144 &#125;145 &#x2F;*146 * 如果temp的下一个结点的编号大于传进来的结点编号，代表temp为要找的位置147 * 例如要插入的是3号，链表中已经有1,2,4了，那么temp就应该是2号的位置148 * *&#x2F;149 if (temp.next.no &gt; list.no)&#123;150 break;151 &#125;else if (temp.next.no &#x3D;&#x3D; list.no)&#123;152 flag &#x3D; true;153 &#125;154 temp&#x3D;temp.next;155 &#125;156 if (flag)&#123;157 System.out.printf(&quot;准备插入的编号 %d 已经存在了, 不能加入\\n&quot;, list.no);158 &#125;else &#123;159 list.next &#x3D; temp.next;160 temp.next&#x3D;list;161 &#125;162 &#125;163 &#x2F;&#x2F;修改链表中的数据164 public void update(List newlist)&#123;165 &#x2F;*166 * 通过查找编号来确定要修改的结点的位置167 * *&#x2F;168 List temp &#x3D; head;&#x2F;&#x2F;使用临时变量存储头结点169 boolean flag &#x3D; false;170 while (true)&#123;171 if (temp &#x3D;&#x3D; null)&#123;172 break;173 &#125;174 if (temp.no &#x3D;&#x3D; newlist.no)&#123;175 flag &#x3D; true;176 break;177 &#125;178 temp&#x3D;temp.next;179 &#125;180 if (flag &#x3D;&#x3D; false)&#123;181 System.out.println(&quot;未找到要修改的编号&quot;);182 &#125;183 else &#123;184 temp.name &#x3D; newlist.name;185 &#125;186 &#125;187 &#x2F;&#x2F;删除链表中的结点188 public void del(List delList)&#123;189 &#x2F;*190 * 删除的思路：191 * 通过函数传入要删除的结点192 * 遍历链表：例如要删除的是3号数据，那么通过遍历，让temp指向2号结点193 * 把2号结点的next指向4号结点，达到删除的功能。此时3号结点没有被2号结点的next指向，会被自动回收内存空间194 * *&#x2F;195 List temp &#x3D; head;&#x2F;&#x2F;使用临时变量存储头结点196 boolean flag &#x3D; false;197 while (true)&#123;198 if (temp &#x3D;&#x3D; null)&#123;199 break;200 &#125;201 if (temp.next.next &#x3D;&#x3D; delList.next)&#123;202 flag &#x3D; true;203 break;204 &#125;205 temp&#x3D;temp.next;206 &#125;207 if (flag)&#123;208 temp.next &#x3D; temp.next.next;209 &#125;210 &#125;211 &#x2F;&#x2F;遍历链表所有数据并显示212 public void show()&#123;213 if(head.next &#x3D;&#x3D; null)&#123;214 System.out.println(&quot;链表为空&quot;);215 return;216 &#125;217 List temp &#x3D; head.next;218 while (true)&#123;219 if (temp &#x3D;&#x3D; null)&#123;220 break;221 &#125;222 System.out.println(temp);223 temp&#x3D;temp.next;&#x2F;&#x2F;指向下一个结点224 &#125;225 &#125;226&#125;227class List &#123;228 public int no;229 public String name;230 public List next; &#x2F;&#x2F;指向下一个节点231 &#x2F;&#x2F;构造器232 public List(int no, String name) &#123;233 this.no &#x3D; no;234 this.name &#x3D; name;235 &#125;236 &#x2F;&#x2F;为了显示方法，我们重新toString237 @Override238 public String toString() &#123;239 return &quot;List [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;240 &#125;241242&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Hibernate入门","slug":"Hibernate","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T06:40:07.672Z","comments":true,"path":"2019/07/02/Hibernate/","link":"","permalink":"http://yoursite.com/2019/07/02/Hibernate/","excerpt":"","text":"1.Hibernate介绍（1）简介Hibernate 是由 Gavin King 于 2001 年创建的开放源代码的对象关系框架。它强大且高效的构建具有关系对象持久性和查询服务的 Java 应用程序。 Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中，并把开发人员从 95% 的公共数据持续性编程工作中解放出来。 Hibernate 是传统 Java 对象和数据库服务器之间的桥梁，用来处理基于 O/R 映射机制和模式的那些对象。Hibernate 优势 Hibernate 使用 XML 文件来处理映射 Java 类别到数据库表格中，并且不用编写任何代码。 为在数据库中直接储存和检索 Java 对象提供简单的 APIs。 如果在数据库中或任何其它表格中出现变化，那么仅需要改变 XML 文件属性。 抽象不熟悉的 SQL 类型，并为我们提供工作中所熟悉的 Java 对象。 Hibernate 不需要应用程序服务器来操作。 操控你数据库中对象复杂的关联。 最小化与访问数据库的智能提取策略。 提供简单的数据询问。 （2）支持的数据库Hibernate 支持几乎所有的主要 RDBMS。以下是一些由 Hibernate 所支持的数据库引擎。 HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server Informix Dynamic Server （3）支持的技术Hibernate 支持多种多样的其它技术，包括以下： XDoclet Spring J2EE Eclipse plug-ins Maven （4）ORM原理 2.Hibernate配置（1）Hibernate.cfg.xml文件配置 1&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39;?&gt;2&lt;!DOCTYPE hibernate-configuration PUBLIC3 &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD&#x2F;&#x2F;EN&quot;4 &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;5&lt;hibernate-configuration&gt;6 &lt;session-factory&gt;7 &lt;!-- 方言（不同数据库中，sql语句略有区别，指定方言可以让hibernate生成sql语句时针对数据库的方言生成），便于hibernate对象操作转化为合适的数据库语句--&gt;8 &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;&#x2F;property&gt;9 &lt;!-- 配置数据库连接--&gt;10 &lt;property name&#x3D;&quot;connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;user?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&lt;&#x2F;property&gt;11 &lt;!-- 配置数据库驱动文件--&gt;12 &lt;property name&#x3D;&quot;connection.driver_class&quot;&gt;com.mysql.cj.jdbc.Driver&lt;&#x2F;property&gt;13 &lt;!--数据库用户名 --&gt;14 &lt;property name&#x3D;&quot;connection.username&quot;&gt;root&lt;&#x2F;property&gt;15 &lt;!--数据库密码 --&gt;16 &lt;property name&#x3D;&quot;connection.password&quot;&gt;root&lt;&#x2F;property&gt;17 &lt;!--是否显示sql语句，sql一般会很难看 默认为false--&gt;18 &lt;property name&#x3D;&quot;show_sql&quot;&gt;true&lt;&#x2F;property&gt;19 &lt;!--下一个层级的映射文件，用来配置bean对象与数据表之间的关系 --&gt;20 &lt;mapping resource&#x3D;&quot;com&#x2F;example&#x2F;UserInfoEntity.hbm.xml&quot;&#x2F;&gt;21 &lt;&#x2F;session-factory&gt;22&lt;&#x2F;hibernate-configuration&gt; （2）配置表与实体对象的关系配置 1&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39;?&gt;2&lt;!DOCTYPE hibernate-mapping PUBLIC3 &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;4 &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;5&lt;!-- package属性：填写一个包名，在后面的属性配置中可以直接写简答类名--&gt;6&lt;hibernate-mapping package&#x3D;&quot;com.example&quot;&gt;7&lt;!--8 class元素：配置实体与表的对应关系9 name：完整类名10 table：数据库表名11--&gt;12 &lt;class name&#x3D;&quot;UserInfoEntity&quot; table&#x3D;&quot;user_info&quot; schema&#x3D;&quot;user&quot;&gt;13 &lt;!--14 id;配置主键映射的属性15 name：填写主键对应的属性名16 column：填写表中的主键列名17 --&gt;18 &lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;19 &lt;!--20 property元素：除id之外的普通属性映射21 name：填写属性名22 column：填写表中对应的列名23 type（可选）：填写列（属性）的类型24 hibernate会自动检测实体的属性类型，建议不填25 每个类型有三种填法：java类型|hibernate类型|数据库类型26 --&gt;27 &lt;property name&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;28 &lt;property name&#x3D;&quot;password&quot; column&#x3D;&quot;password&quot;&#x2F;&gt;29 &lt;property name&#x3D;&quot;nickname&quot; column&#x3D;&quot;nickname&quot;&#x2F;&gt;30 &lt;property name&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;31 &lt;&#x2F;class&gt;32&lt;&#x2F;hibernate-mapping&gt; 3.Hibernate API详解1&#x2F;&#x2F;1.创建对象，调用空参构造2 Configuration conf &#x3D; new Configuration();3 &#x2F;&#x2F;2.读取指定主配置文件 ---&gt;空参构造，加载src下的hibernate.cfg.xml文件4 conf.configure();5 &#x2F;&#x2F;3.根据配置信息，创建SessionFactory对象6 SessionFactory sessionFactory &#x3D; conf.buildSessionFactory();7 &#x2F;*8 &lt;!--SessionFactory功能：用户创建数据库核心对象Session对象的工厂910 简单来说就是功能就是创建session对象1112 注意：a.sessionFactory 负责保存和使用所有配置信息，消耗内存资源很大1314 b.session属于线程安全的对象设计1516 结论：保证在web项目中，只创建一个sessionFactory对象*&#x2F;1718 &#x2F;&#x2F;4.获得session19 &#x2F;&#x2F;打开一个新的session20 sessionFactory.openSession();21 &#x2F;&#x2F;获得一个与线程绑定的session对象22 sessionFactory.getCurrentSession(); session对象功能：表达hibernate框架与数据库之间的连接（会话） ​ 类似于JDBC中的connection对象，还可以完成对数据库中的增删改查 ​ session是hibernate操作数据库的核心对象 1package test;2import com.example.UserInfoEntity;3import org.hibernate.Session;4import org.hibernate.SessionFactory;5import org.hibernate.Transaction;6import org.hibernate.cfg.Configuration;7public class test &#123;8 public static void main(String [] args) &#123;9 Configuration conf &#x3D; new Configuration().configure();10 SessionFactory sessionFactory &#x3D; conf.buildSessionFactory();11 Session session &#x3D; sessionFactory.openSession();12 Transaction transaction1 &#x3D; session.beginTransaction();13 &#x2F;&#x2F;增加14 &#x2F;*UserInfoEntity u &#x3D; new UserInfoEntity();15 u.setId(&quot;5&quot;);16 u.setNickname(&quot;轨迹11&quot;);17 u.setUsername(&quot;黄阳11&quot;);18 u.setPassword(&quot;1231&quot;);19 u.setSex(&quot;男&quot;);20 session.save(u);*&#x2F;21 &#x2F;*查询 22 UserInfoEntity u &#x3D; session.get(UserInfoEntity.class, &quot;1&quot;);23 System.out.println(u);*&#x2F;24 &#x2F;*修改25 UserInfoEntity u &#x3D; session.get(UserInfoEntity.class, &quot;1&quot;);26 u.setNickname(&quot;李四1111&quot;);27 session.update(u);*&#x2F;28 &#x2F;*删除29 UserInfoEntity u &#x3D; session.get(UserInfoEntity.class, &quot;1&quot;);30 session.delete(u);*&#x2F;31 transaction1.commit();&#x2F;&#x2F;提交事务32 session.close();&#x2F;&#x2F;释放资源33 sessionFactory.close();&#x2F;&#x2F;释放资源34 &#125;35&#125; 总结基本步骤： 获得configuration对象 获得sessionFactory对象 获得session对象 获得transaction对象并开启事务 执行数据操作（增删改查） 提交事务 释放资源 4.Hibernate简单封装package Utils; import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration; public class hibernateUtils { private static SessionFactory sessionFactory; static { Configuration conf = new Configuration().configure(); sessionFactory = conf.buildSessionFactory(); } //获得全新session public static Session openSession(){ Session session = sessionFactory.openSession(); return session; } //获得与线程绑定的session public static Session getCurrentSession(){ Session session = sessionFactory.getCurrentSession(); return session; } public static void main(String [] args) { System.out.println(hibernateUtils.openSession()); }}","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"response响应对象","slug":"response响应对象","date":"2019-06-30T16:00:00.000Z","updated":"2019-07-01T11:44:11.599Z","comments":true,"path":"2019/07/01/response响应对象/","link":"","permalink":"http://yoursite.com/2019/07/01/response%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1/","excerpt":"1.提供的方法void addCookie(Cookie cookie);​ 服务端向客户端增加cookie对象 void sendRedirect(String location) throw IOException;​ 页面跳转的一种方式(重定向) void setContetType(String type);​ 设置服务端响应的编码(contentType类型)","text":"1.提供的方法void addCookie(Cookie cookie);​ 服务端向客户端增加cookie对象 void sendRedirect(String location) throw IOException;​ 页面跳转的一种方式(重定向) void setContetType(String type);​ 设置服务端响应的编码(contentType类型) 2.示例：登陆页面校验login.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;form action&#x3D;&quot;check.jsp&quot;method&#x3D;&quot;post&quot;&gt;8 用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;br&#x2F;&gt;9 密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;userpwd&quot;&gt;&lt;br&#x2F;&gt;10 &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;11 &lt;&#x2F;form&gt;12&lt;&#x2F;body&gt;13&lt;&#x2F;html&gt; check.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;%8 request.setCharacterEncoding(&quot;utf-8&quot;);&#x2F;&#x2F;设置编码9 String name&#x3D;request.getParameter(&quot;username&quot;);10 String pwd&#x3D;request.getParameter(&quot;userpwd&quot;);11 if(name.equals(&quot;zs&quot;)&amp;&amp;pwd.equals(&quot;abc&quot;))&#123;12 &#x2F;&#x2F; 会导致数据丢失13 &#x2F;&#x2F; response.sendRedirect(&quot;success.jsp&quot;);14 &#x2F;&#x2F; 换成请求转发15 request.getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response);16 &#x2F;&#x2F;页面跳转：请求转发，可以获取到数据，地址栏没有改变（仍然保留转发时的地址栏）17 &#125;18 else &#123;19 out.print(&quot;账号密码错误&quot;);20 &#125;21 %&gt;22&lt;&#x2F;body&gt;23&lt;&#x2F;html&gt; success.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7登录成功！&lt;&#x2F;br&gt;8欢迎您9&lt;%10 String name&#x3D;request.getParameter(&quot;username&quot;);11 out.print(name);12%&gt;13&lt;&#x2F;body&gt;14&lt;&#x2F;html&gt; 3.请求转发和重定向的区别请求转发：getRequestDispatcher(&quot;success.jsp&quot;).forward(request,response); 重定向：response.sendRedirect(&quot;success.jsp&quot;); 请求转发 重定向​ 地址栏是否改变 不改变 改变 ​ 是否保留第一次请求时的数据 保留 不保留 ​ 请求的次数 1次 2次 ​ 跳转发生的位置 服务端 客户端 请求转发：在服务器内部跳转，可以携带数据 1555738079345 重定向返回给客户端让客户端重新发起跳转，不携带数据 原因：重定向两次请求，而request请求的作用域在当前一次请求有效，第二次请求不会有第一次请求的参数，所以数据丢失 1555738113918 1555738671040 例：​ 张三去银行办理业务： 请求转发：​ 张三（客户端） ——&gt; 【服务窗口A（服务端）——&gt;服务窗口B】 （【】内视为一个服务端） ​ 在这里张三只找了A，只有一次请求，A自己去找B将事情解决，所以地址栏不变 重定向：​ 张三（客户端） ——&gt; 服务窗口A（服务端）——&gt;去找服务窗口B ​ 张三（客户端） ——&gt; 服务窗口B（服务端） ​ 在这里张三找了两个人，有两次请求，所以地址栏会改变 4.session和Cookiesession(服务端)、Cookie(客户端，不是内置对象)：Cookie是客户端对象，却是由服务端产生，再发送给客户端保存 Cookie是本地缓存。 ​ 本地缓存的作用：可以提高访问效率，但是安全性较差，因为还可以保存密码 ​ 例如在网上看电影：客户端 —&gt;服务端（hello.mp4） ​ 第一次客户端向服务端请求hello.mp4观看。服务端将电影放进Cookie里发送给客户端。下次 观看只需从本机观看。 Cookie：name =value Cookie来自java.servlet.http.Cookie public Cookie(String name,String value) String getName() //获取name String getValue() //获取value void setMaxage(int expiry) //设置最大有效期（秒） 服务端发送Cookie给客户端： 步骤：服务端准备Cookie： response.addCookie(Cookie cookie); 页面跳转（转发，重定向）; 客户端获取: cookie:request.getCookies(); //获取cookie必须全部获取，不可以获取其中一个 示例代码：addCookie.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;%8 &#x2F;&#x2F;服务端9 Cookie cookie1&#x3D;new Cookie(&quot;name&quot;,&quot;zs&quot;);10 Cookie cookie2&#x3D;new Cookie(&quot;pwd&quot;,&quot;abc&quot;);11 response.addCookie(cookie1);12 response.addCookie(cookie2);13 response.sendRedirect(&quot;result.jsp&quot;);14 %&gt;15&lt;&#x2F;body&gt;16&lt;&#x2F;html&gt; result.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;%8 Cookie[] cookies&#x3D;request.getCookies();9 for (Cookie cookie:cookies)&#123;10 out.print(cookie.getName()+&quot;----&quot;+cookie.getValue());11 &#125;12 %&gt;13&lt;&#x2F;body&gt;14&lt;&#x2F;html&gt; 结果： 1555742270529 通过结果发现除了自己设置的cookie，还有一个name为JSESSIONID的cookie session在一个浏览器窗口中是唯一的，把数据存储在tomcat服务器中，这个数据就是session session存储在cookie中","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"JSP页面元素及request对象","slug":"JSP页面元素及request对象","date":"2019-06-30T16:00:00.000Z","updated":"2019-07-01T08:38:03.358Z","comments":true,"path":"2019/07/01/JSP页面元素及request对象/","link":"","permalink":"http://yoursite.com/2019/07/01/JSP%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%8F%8Arequest%E5%AF%B9%E8%B1%A1/","excerpt":"1.jsp页面元素：html、java代码、注释、指令","text":"1.jsp页面元素：html、java代码、注释、指令 a.脚本Scriptlet &lt;% ​ 局部变量、java语句 ​ %&gt; 2.&lt;%! 全局变量、java语句 %&gt; 3.&lt;%=输出表达式%&gt; 一般而言：修改web.xml 、配置文件、java 需要重启服务器 修改jsp、html、css、js不需要重启 b.指令page指令：写在开头 &lt;% page ……..%&gt; page指令属性：1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.Date&quot; %&gt; language：jsp页面使用的脚本语言 import：导入类 pageEncoding：jsp文件自身编码 jsp-&gt;java contentType:浏览器解析jsp的编码 c.注释注释共三个： html： java： // jsp:&lt;%– –%&gt; 2.Jsp9大内置对象(自带的，不需要new可以使用的对象) 1558945927713 out：​ 输出对象，向客户端输出内容 pageContext：request：​ 请求对象；存储“客户端向服务端发送的请求信息” 常见方法：​ String getParameter(String name):根据请求的字段名key，返回字段值value ​ String[] getParameterValues(String name)：根据请求的字段名key，返回多个字段值 value ​ void setCharacterEncoding(“编码格式utf-8”)：设置请求编码（不设置会使用tomcat的默 认编码，tomcat7以前是iso-8859-1， tomcat8以后是utf-8） ​ getRequestDispatcher(“b.jsp”).forward(request,response); 请求转发 A-B ​ getServerContext(); 获取项目的ServletContext对象 示例：注册页面​ 提交参数可以通过表单也可以通过地址栏，都称作get方式 ​ 地址栏：http://localhost:8080/ideaproject_war_exploded/show.jsp?username=aaa&amp;userpwd=1aaa&amp;userage=11&amp;userh=%E8%B6%B3%E7%90%83&amp;userh=%E7%AF%AE%E7%90%83 ​ get方式：&lt;form action=”show.jsp”method=”get”&gt; ​ post方式：&lt;form action=”show.jsp”method=”post”&gt; get和post区别：​ get方式地址栏容纳的大小有限（4-5kb），不安全。文件上传必须用post ​ 用post方式最好，因为post不会在地址栏显示提交的参数信息。 ​ register.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;form action&#x3D;&quot;show.jsp&quot;&gt;8 用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;br&#x2F;&gt;9 密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;userpwd&quot;&gt;&lt;br&#x2F;&gt;10 年龄：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;userage&quot;&gt;&lt;br&#x2F;&gt;11 爱好：&lt;br&#x2F;&gt;12 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;userh&quot; value&#x3D;&quot;足球&quot;&gt;&lt;br&#x2F;&gt;足球13 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;userh&quot; value&#x3D;&quot;篮球&quot;&gt;&lt;br&#x2F;&gt;篮球14 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;userh&quot; value&#x3D;&quot;羽毛球&quot;&gt;&lt;br&#x2F;&gt;羽毛球15 &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;1617 &lt;&#x2F;form&gt;18&lt;&#x2F;body&gt;19&lt;&#x2F;html&gt; ​ show.jsp 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;2&lt;html&gt;3&lt;head&gt;4 &lt;title&gt;Title&lt;&#x2F;title&gt;5&lt;&#x2F;head&gt;6&lt;body&gt;7 &lt;%8 request.setCharacterEncoding(&quot;utf-8&quot;);&#x2F;&#x2F;设置编码9 String name&#x3D;request.getParameter(&quot;username&quot;);10 int age&#x3D;Integer.parseInt(request.getParameter(&quot;userage&quot;));11 String pwd&#x3D;request.getParameter(&quot;userpwd&quot;);12 String[] h&#x3D;request.getParameterValues(&quot;userh&quot;);13 %&gt;14 姓名：&lt;%&#x3D;name%&gt;&lt;br&#x2F;&gt;15 年龄：&lt;%&#x3D;age%&gt;&lt;br&#x2F;&gt;16 密码：&lt;%&#x3D;pwd%&gt;&lt;br&#x2F;&gt;17 爱好：&lt;br&#x2F;&gt;18 &lt;%19 for (String hobby:h)&#123;20 out.print(hobby+&quot;&amp;nbsp;&quot;);&#x2F;&#x2F;&amp;nbsp代表空格，转义字符21 &#125;22 %&gt;2324&lt;&#x2F;body&gt;25&lt;&#x2F;html&gt; responsesessionapplicationconfigpageexception","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]}]}